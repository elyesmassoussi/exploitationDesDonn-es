package org.exemple.population.function.parser;

import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;
import lombok.extern.slf4j.Slf4j;
import org.apache.spark.sql.*;

import org.example.entities.beans.Population;
import org.example.functions.writer.Writer;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

@Slf4j
public class WriterTest {
    @Test
    public void writerTest() throws IOException {
        Encoder<Population> popEncoder = Encoders.bean(Population.class);
        SparkSession spark = SparkSession.builder()
                .appName("spark")
                .master("local[2]")
                .getOrCreate();


        /*
        List<Population> popList = new ArrayList<>() ;
        popList.add(Population.builder()
                .annee("1992")
                .popMunicipale("568932")
                .popComptee("01004")
                .popTotale("35789")
                .build());


         */
        Dataset<Population> javaBeanDS = spark.createDataset(
                Collections.singletonList(Population.builder()
                        .annee("1992")
                        .popMunicipale("568932")
                        .popComptee("01004")
                        .popTotale("35789")
                        .build()),
                popEncoder
        );
        javaBeanDS.show();

        Config config = ConfigFactory.load("application.conf");
        String outputPath = config.getString("app.data.output") ;

        Writer csvWriter = new Writer(outputPath) ;

        csvWriter.accept(javaBeanDS);


        Path output = Paths.get(outputPath);
        Stream<Path> jsonFilePaths = Files.list(output)
                .filter(p -> p.getFileName().toString().startsWith("part-") && p.toString().endsWith(".csv"))
                ;
        List<String> lines=jsonFilePaths
                .flatMap(
                        outputJsonfilepath ->{
                            Stream<String> jsonFileContent= Stream.empty();
                            try {
                                jsonFileContent=Files.lines(outputJsonfilepath);
                            }
                            catch (IOException e)
                            {
                                log.info("ccc");
                            }
                            return jsonFileContent;

                        }
                )
                .collect(Collectors.toList());
        assertThat(lines)
                .isNotEmpty()
                .contains("1992,01004,568932,35789")

        ;

    }




}
